<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces.Desktop</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver">
            <summary>
            Resolves metadata references specified in source code (#r directives).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.SearchPaths">
            <summary>
            Search paths used when resolving metadata references.
            </summary>
            <remarks>
            All search paths are absolute.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory">
            <summary>
            Directory used for resolution of relative paths.
            A full directory path or null if not available.
            </summary>
            <remarks>
            This directory is only used if the base directory isn't implied by the context within which the path is being resolved.
            
            It is used, for example, when resolving a strong name key file specified in <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/>,
            or a metadata file path specified in <see cref="P:Microsoft.CodeAnalysis.PortableExecutableReference.FilePath"/>.
            
            Resolution of a relative path that needs the base directory fails if the base directory is null.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.ResolveReference(System.String,System.String)">
            <summary>
            Resolves a metadata reference that is a path or an assembly name.
            </summary>
            <param name="reference">Reference path.</param>
            <param name="baseFilePath">
            The base file path to use to resolve relative paths against.
            Null to use the <see cref="P:Microsoft.CodeAnalysis.MetadataFileReferenceResolver.BaseDirectory"/> as a base for relative paths.
            </param>
            <returns>
            Normalized absolute path to the referenced file or null if it can't be resolved.
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.source">
            <summary>
            Underlying string on which this SourceText instance is based
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.EncodedStringText"/> with provided bytes.
            </summary>
            <param name="stream"></param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Source">
            <summary>
            Underlying string which is the source of this SourceText instance
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Length">
            <summary>
            The length of the text represented by <see cref="T:Microsoft.CodeAnalysis.Text.EncodedStringText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="P:Microsoft.CodeAnalysis.Text.EncodedStringText.Length"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.IsBinary(System.String)">
            <summary>
            The heuristic checks
            for occurrence of two consecutive NUL (U+0000) characters in the stream, which are 
            highly unlikely to appear in a text file. Since the heuristic is applied after 
            the text has been decoded, it can be used with any encoding.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,System.Text.Encoding@)">
            <summary>
            Decode the given stream using the given encoding. Does not
            close the stream afterwards.
            </summary>
            <param name="data">Data stream</param>
            <param name="encoding">Default encoding to use for decoding.</param>
            <param name="actualEncoding">Actual encoding used to read the text.</param>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/> as its fallback decoder.</exception>
            <returns>Decoded stream as a text string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.ReadUnicodeStringFromMemoryMappedViewStream(System.IO.MemoryMappedFiles.MemoryMappedViewStream)">
            <summary>
            Read a Unicode string from a memory mapped view. The stream is not closed on exit.
            </summary>
            <param name="memoryMappedViewStream">A view over a memory mapped stream which contains a Unicode string (preceded by a Unicode BOM)</param>
            <returns>The string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryDecodeMemoryStream(System.IO.MemoryStream,System.Text.Encoding,System.Text.Encoding@,System.String@)">
            <summary>
            If the MemoryStream was created with publiclyVisible=true, then we can access its buffer
            directly and save allocations in StreamReader. The input MemoryStream is not closed on exit.
            </summary>
            <exception cref="T:System.Text.DecoderFallbackException">If the given encoding is set to use <see cref="T:System.Text.DecoderExceptionFallback"/> 
            as its fallback decoder.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyName(Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName)">
            <summary>
            Converts <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with possibly missing name components.
            </summary>
            <returns>
            An <see cref="T:System.Reflection.AssemblyName"/> whose fields are be null if not present in <paramref name="nameObject"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyIdentity(Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName)">
            <summary>
            Converts <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with all metadata fields filled.
            </summary>
            <returns>
            Assembly name with Version, Culture and PublicKeyToken components filled in:
            "SimpleName, Version=#.#.#.#, Culture=XXX, PublicKeyToken=XXXXXXXXXXXXXXXX".
            In addition Retargetable flag and ContentType are set.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyNameObject(System.Reflection.AssemblyName)">
            <summary>
            Converts <see cref="T:System.Reflection.AssemblyName"/> to an equivalent <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.ToAssemblyNameObject(System.String)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName"/> object by parsing given display name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FusionAssemblyIdentity.GetBestMatch(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FusionAssemblyIdentity.IAssemblyName},System.String)">
            <summary>
            Selects the candidate assembly with the largest version number.  Uses culture as a tie-breaker if it is provided.
            All candidates are assumed to have the same name and must include versions and cultures.  
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GlobalAssemblyCache">
            <summary>
            Provides APIs to enumerate and look up assemblies stored in the Global Assembly Cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.GlobalAssemblyCache.CurrentArchitectures">
            <summary>
            Represents the current Processor architecture
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblyIdentities(System.Reflection.AssemblyName,System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">Optional partial name.</param>
            <param name="architectureFilter">Optional architecture filter.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblyIdentities(System.String,System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">The optional partial name.</param>
            <param name="architectureFilter">The optional architecture filter.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.GetAssemblySimpleNames(System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture})">
            <summary>
            Enumerates assemblies in the GAC returning their simple names.
            </summary>
            <param name="architectureFilter">Optional architecture filter.</param>
            <returns>Unique simple names of GAC assemblies.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.ResolvePartialName(System.String,System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture},System.Globalization.CultureInfo)">
            <summary>
            Looks up specified partial assembly name in the GAC and returns the best matching <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>.
            </summary>
            <param name="displayName">The display name of an assembly</param>
            <param name="architectureFilter">The optional processor architecture</param>
            <param name="preferredCulture">The optional preferred culture information</param>
            <returns>An assembly identity or null, if <paramref name="displayName"/> can't be resolved.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GlobalAssemblyCache.ResolvePartialName(System.String,System.String@,System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture},System.Globalization.CultureInfo)">
            <summary>
            Looks up specified partial assembly name in the GAC and returns the best matching <see cref="T:Microsoft.CodeAnalysis.AssemblyIdentity"/>.
            </summary>
            <param name="displayName">The display name of an assembly</param>
            <param name="location">Full path name of the resolved assembly</param>
            <param name="architectureFilter">The optional processor architecture</param>
            <param name="preferredCulture">The optional preferred culture information</param>
            <returns>An assembly identity or null, if <paramref name="displayName"/> can't be resolved.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a content loader for specified file.
            </summary>
            <param name="path">An absolute file path.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an absolute path.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.Path">
            <summary>
            Absolute path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding">
            <summary>
            Specifies an encoding to be used if the actual encoding of the file 
            can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If <c>null</c> auto-detect heristics are used to determine the encoding. 
            If these heuristics fail the decoding is assumed to be <see cref="P:System.Text.Encoding.Default"/>.
            Note that if the stream starts with Byte Order Mark the value of <see cref="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding"/> is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices">
            <summary>
            A class that provides host services via classes instances exported via a MEF version 1 composition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> associated with the specified workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``2">
            <summary>
            Gets all the MEF exports of the specified type with the specified metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices.GetExports``1">
            <summary>
            Gets all the MEF exports of the specified type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedFileManager">
            <summary>
            Rather than creating a separate MemoryMappedFile for every string/stream we need to persist,
            use several large MemoryMappedFile 'arenas' that contain multiple buffers each.
            
            Group buffers by size to simplify fragmentation and complexity of this memory management code.
            Currently, anything larger than 256KB will get its own MemoryMappedFile.
            
            When opening Roslyn.sln and doing a full initialization through Solution Navigator, we get
            8000+ requests.  Since the minimum OS allocation for a memory mapped file is rounded up to 
            64KB, this would map ~500MB alone, not counting the additional space needed for files > 64KB.
            Using the strategy below for the same scenario, we create only 90 4MB arenas which hold all but
            104 buffers that are larger than 256KB.  So we avoid creating ~7500 MemoryMappedFile objects
            and save roughly 400MB of fragmentation when compared to the simple one MemoryMappedFile per
            request approach.
            
            The MemoryMappedFileManager, MemoryMappedFileArena, and MemoryMappedInfo classes all
            have very tight coupling in the current implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.streamCount">
            <summary>
            ref count of stream given out
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.accessor">
            <summary>
            actual memory accessor that owns the VM
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            Get underlying native memory directly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.AcquirePointer(System.IO.MemoryMappedFiles.MemoryMappedViewAccessor)">
            <summary>
            Acquire the fixed pointer to the start of the memory mapped view.
            The pointer will be released during <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.Dispose(System.Boolean)"/>
            </summary>
            <returns>The pointer to the start of the memory mapped view. The pointer is valid, and remains fixed for the lifetime of this object.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace">
            <summary>
            A workspace that can be populated by opening MSBuild solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">An optional set of MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Create(System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.CodeAnalysis.Host.HostServices)">
            <summary>
            Create a new instance of a workspace that can be populated by opening solution and project files.
            </summary>
            <param name="properties">The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.</param>
            <param name="hostServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> used to configure this workspace.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.Properties">
            <summary>
            The MSBuild properties used when interpreting project files.
            These are the same properties that are passed to msbuild via the /property:&lt;n&gt;=&lt;v&gt; command line argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.LoadMetadataForReferencedProjects">
            <summary>
            Determines if metadata from existing output assemblies is loaded instead of opening referenced projects.
            If the referenced project is already opened, the metadata will not be loaded.
            If the metadata assembly cannot be found the referenced project will be opened instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.SkipUnrecognizedProjects">
            <summary>
            Determines if unrecognized projects are skipped when solutions or projects are opened.
            
            An project is unrecognized if it either has 
              a) an invalid file path, 
              b) a non-existent project file,
              c) has an unrecognized file extension or 
              d) a file extension associated with an unsupported language.
            
            If unrecognized projects cannot be skipped a corresponding exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.AssociateFileExtensionWithLanguage(System.String,System.String)">
            <summary>
            Associates a project file extension with a language name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.CloseSolution">
            <summary>
            Close the open solution, and reset the workspace to a new empty solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a solution file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.OpenProjectAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Open a project file and all referenced projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace.GetProjectMetadata(System.String,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Gets a MetadataReference to a project's output assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.BuildTargets">
            <summary>
            Defines a list of build targets and operations to modify that list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.BuildTargets.Remove(System.String)">
            <summary>
            Remove the specified target from the build targets. 
            
            If the target is nested (a dependent target) of one of the build targets, 
            promote the siblings of the target to the formal list (in execution order.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.BuildTargets.RemoveAfter(System.String,System.Boolean)">
            <summary>
            Remove all targets after the specified target (and possibly also remove the specified target).
            
            If a removed target is nested (a dependent target) of one of the build targets, 
            promote the siblings of the removed target to the formal list (in execution order).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo">
            <summary>
            Represents a source file that is part of a project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.FilePath">
            <summary>
            The absolute path to the document file on disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.LogicalPath">
            <summary>
            A fictional path to the document, relative to the project.
            The document may not actually exist at this location, and is used
            to represent linked documents. This includes the file name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsLinked">
            <summary>
            True if the document has a logical path that differs from its 
            absolute file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo.IsGenerated">
            <summary>
            True if the file was generated during build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.IProjectFile">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.FilePath">
            <summary>
            The path to the project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Guid">
            <summary>
            The unique GUID associated with the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetProjectFileInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the project file info asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetSourceCodeKind(System.String)">
            <summary>
            Get the kind of source found in the specified file. 
            This is usually determined by the file name extension.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetDocumentExtension(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Gets the corresponding extension for a source file of a given kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.GetPropertyValue(System.String)">
            <summary>
            Gets a specific project file property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.AddDocument(System.String,System.String)">
            <summary>
            Add a source document to a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.RemoveDocument(System.String)">
            <summary>
            Remove a source document from a project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.IProjectFile.Save">
            <summary>
            Save the current state of the project file to disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MSBuild.ProjectFile.GetAbsolutePath(System.String)">
            <summary>
            Resolves the given path that is possibly relative to the project directory.
            </summary>
            <remarks>
            The resulting path is absolute but might not be normalized.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo">
            <summary>
            Represents a project file loaded from disk.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Guid">
            <summary>
            The project's individual GUID
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.OutputFilePath">
            <summary>
            The path to the output file this project generates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AssemblyName">
            <summary>
            The assembly name of the output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.CompilationOptions">
            <summary>
            The compilation options for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ParseOptions">
            <summary>
            The parse options for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.CodePage">
            <summary>
            The codepage for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.Documents">
            <summary>
            The source documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AdditionalDocuments">
            <summary>
            The additional documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.ProjectReferences">
            <summary>
            References to other projects.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.MetadataReferences">
            <summary>
            References to other metadata files; libraries and executables.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo.AnalyzerReferences">
            <summary>
            References to analyzer assembly files; contains diagnostic analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference">
            <summary>
            Represents a reference to another project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Path">
            <summary>
            The path on disk to the other project file. 
            This path may be relative to the referencing project's file or an absolute path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MSBuild.ProjectFileReference.Aliases">
            <summary>
            The aliases assigned to this reference, if any.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MSBuild.SectionBlock">
            <summary>
            Represents a SectionBlock in a .sln file. Section blocks are of the form:
            
            Type(ParenthesizedName) = Value
                Key = Value
                [more keys/values]
            EndType
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.FileKey.Timestamp">
            <summary>
            Last write time (UTC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (UTC).</param>
        </member>
        <member name="M:Roslyn.Utilities.FileKey.Create(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.FileStream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            Note that after doing this the file can't be opened again, not even by the same process.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it
                doesn't check for invalid path characters, 
                doesn't strip any trailing directory separators (TODO: tomat),
                doesn't recognize UNC structure \\computer-name\share\directory-name\file-name (TODO: tomat).
            </remarks>
            <returns>Prefix of path that represents a directory. </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Get a prefix of given path which is the root of the path.
            </summary>
            <returns>
            Root of an absolute path or null if the path isn't absolute or has invalid format (e.g. "\\").
            It may or may not end with a directory separator (e.g. "C:\", "C:\foo", "\\machine\share", etc.) .
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetUncPathRootLength(System.String)">
            <summary>
            Calculates the length of root of an UNC path.
            </summary>
            <remarks>
            "\\server\share" is root of UNC path "\\server\share\dir1\dir2\file".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="rootOpt">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="rootOpt"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.GacFileResolver">
            <summary>
            Extends <see cref="T:Microsoft.CodeAnalysis.MetadataFileReferenceResolver"/> to enable resolution of assembly
            simple names in the GAC.
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.GacFileResolver.Default">
            <summary>
            A resolver that is configured to resolve against the GAC associated
            with the bitness of the currently executing process.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.GacFileResolver.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Immutable.ImmutableArray{System.Reflection.ProcessorArchitecture},System.Globalization.CultureInfo)">
            <summary>
            Constructs an instance of a <see cref="T:Roslyn.Scripting.GacFileResolver"/>
            </summary>
            <param name="assemblySearchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
            <param name="architectures">Supported architectures used to filter GAC assemblies.</param>
            <param name="preferredCulture">A culture to use when choosing the best assembly from 
            among the set filtered by <paramref name="architectures"/></param>
        </member>
        <member name="P:Roslyn.Scripting.GacFileResolver.Architectures">
            <summary>
            Architecture filter used when resolving assembly references.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.GacFileResolver.PreferredCulture">
            <summary>
            CultureInfo used when resolving assembly references.
            </summary>
        </member>
    </members>
</doc>
